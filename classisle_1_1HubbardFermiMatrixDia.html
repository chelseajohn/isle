<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>isle: isle::HubbardFermiMatrixDia Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">isle
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">Lattice Monte Carlo for Carbon Nanostructures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classisle_1_1HubbardFermiMatrixDia.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classisle_1_1HubbardFermiMatrixDia-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">isle::HubbardFermiMatrixDia Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a fermion matrix \(M\) for the Hubbard model with hopping matrix on the diagonal.  
 <a href="classisle_1_1HubbardFermiMatrixDia.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hubbardFermiMatrixDia_8hpp_source.html">hubbardFermiMatrixDia.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for isle::HubbardFermiMatrixDia:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classisle_1_1HubbardFermiMatrixDia__coll__graph.png" border="0" usemap="#isle_1_1HubbardFermiMatrixDia_coll__map" alt="Collaboration graph"/></div>
<map name="isle_1_1HubbardFermiMatrixDia_coll__map" id="isle_1_1HubbardFermiMatrixDia_coll__map">
<area shape="rect" id="node2" href="classisle_1_1Cache.html" title="isle::Cache\&lt; isle::\lcpp_wrappers::Matrix,\l std::function\&lt; isle\l::cpp_wrappers::Matrix()\&gt; \&gt;" alt="" coords="273,5,475,76"/>
<area shape="rect" id="node3" href="classisle_1_1cpp__wrappers_1_1Matrix.html" title="Wrapper around datatype specific matrices in isle_cpp. " alt="" coords="5,27,184,54"/>
<area shape="rect" id="node4" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html" title="isle.cpp_wrappers::\lSparseMatrix\&lt; double \&gt;" alt="" coords="285,100,463,141"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">QLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of an LU-decomposition of Q.  <a href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39e0ea48aee7f69ae6c81181fc730909"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a39e0ea48aee7f69ae6c81181fc730909">HubbardFermiMatrixDia</a> (const <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; double &gt; &amp;<a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a616f6a1a413cdaa537b055ae5d8e5a7e">kappaTilde</a>, double <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#ad909d60ba496b017b583736fdbff926d">muTilde</a>, std::int8_t <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a3bd0a80c5e1109aa52fe38cb384be23f">sigmaKappa</a>)</td></tr>
<tr class="memdesc:a39e0ea48aee7f69ae6c81181fc730909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all necessary parameters to later construct the full fermion matrix.  <a href="#a39e0ea48aee7f69ae6c81181fc730909">More...</a><br /></td></tr>
<tr class="separator:a39e0ea48aee7f69ae6c81181fc730909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ee0d4de16760710c949d3bd285f251"><td class="memItemLeft" align="right" valign="top"><a id="ad1ee0d4de16760710c949d3bd285f251"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HubbardFermiMatrixDia</b> (const <a class="el" href="classisle_1_1Lattice.html">Lattice</a> &amp;lat, double beta, double <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#ad909d60ba496b017b583736fdbff926d">muTilde</a>, std::int8_t <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a3bd0a80c5e1109aa52fe38cb384be23f">sigmaKappa</a>)</td></tr>
<tr class="separator:ad1ee0d4de16760710c949d3bd285f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ac97b3a142a5f93a36991d652574b9"><td class="memItemLeft" align="right" valign="top"><a id="a31ac97b3a142a5f93a36991d652574b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HubbardFermiMatrixDia</b> (const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;other)</td></tr>
<tr class="separator:a31ac97b3a142a5f93a36991d652574b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72868816716a2fc9237fa4f0b0941d1e"><td class="memItemLeft" align="right" valign="top"><a id="a72868816716a2fc9237fa4f0b0941d1e"></a>
<a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;other)</td></tr>
<tr class="separator:a72868816716a2fc9237fa4f0b0941d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28048fbc1370449841405f6b43fb9d07"><td class="memItemLeft" align="right" valign="top"><a id="a28048fbc1370449841405f6b43fb9d07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HubbardFermiMatrixDia</b> (<a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a28048fbc1370449841405f6b43fb9d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fec3c0d0077c38138972568b8726a5f"><td class="memItemLeft" align="right" valign="top"><a id="a6fec3c0d0077c38138972568b8726a5f"></a>
<a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a6fec3c0d0077c38138972568b8726a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951da2a77107d06560c83fa65a22b1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a1951da2a77107d06560c83fa65a22b1e">K</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a> &amp;k, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species) const</td></tr>
<tr class="memdesc:a1951da2a77107d06560c83fa65a22b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the diagonal block K of matrix M in the parameter.  <a href="#a1951da2a77107d06560c83fa65a22b1e">More...</a><br /></td></tr>
<tr class="separator:a1951da2a77107d06560c83fa65a22b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe8aa1a749e01483c9be5056fa9d191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#aefe8aa1a749e01483c9be5056fa9d191">K</a> (<a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species) const</td></tr>
<tr class="memdesc:aefe8aa1a749e01483c9be5056fa9d191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the diagonal block matrix K of matrix M.  <a href="#aefe8aa1a749e01483c9be5056fa9d191">More...</a><br /></td></tr>
<tr class="separator:aefe8aa1a749e01483c9be5056fa9d191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2c0163bb762f31c011274ddd528a0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#aae2c0163bb762f31c011274ddd528a0a">Kinv</a> (<a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species) const</td></tr>
<tr class="memdesc:aae2c0163bb762f31c011274ddd528a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse of the diagonal block matrix K of matrix M.  <a href="#aae2c0163bb762f31c011274ddd528a0a">More...</a><br /></td></tr>
<tr class="separator:aae2c0163bb762f31c011274ddd528a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32039da45c62a79868918b0d5fc47011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a32039da45c62a79868918b0d5fc47011">F</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;f, std::size_t tp, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species, bool inv=false) const</td></tr>
<tr class="memdesc:a32039da45c62a79868918b0d5fc47011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an off-diagonal block F of matrix M in the parameter.  <a href="#a32039da45c62a79868918b0d5fc47011">More...</a><br /></td></tr>
<tr class="separator:a32039da45c62a79868918b0d5fc47011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c2cb52fa57fee1de71d36aec4570c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a59c2cb52fa57fee1de71d36aec4570c3">F</a> (std::size_t tp, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species, bool inv=false) const</td></tr>
<tr class="memdesc:a59c2cb52fa57fee1de71d36aec4570c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an off-diagonal block matrix F of matrix M.  <a href="#a59c2cb52fa57fee1de71d36aec4570c3">More...</a><br /></td></tr>
<tr class="separator:a59c2cb52fa57fee1de71d36aec4570c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ee41a7290eabe1e8e2e5cddae6d37f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#ae0ee41a7290eabe1e8e2e5cddae6d37f">M</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;m, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species) const</td></tr>
<tr class="memdesc:ae0ee41a7290eabe1e8e2e5cddae6d37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the matrix \(M\) in the parameter.  <a href="#ae0ee41a7290eabe1e8e2e5cddae6d37f">More...</a><br /></td></tr>
<tr class="separator:ae0ee41a7290eabe1e8e2e5cddae6d37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd6e2dee678cb8c1db6f3c6673ebda6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a0cd6e2dee678cb8c1db6f3c6673ebda6">M</a> (const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species) const</td></tr>
<tr class="memdesc:a0cd6e2dee678cb8c1db6f3c6673ebda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the matrix \(M\).  <a href="#a0cd6e2dee678cb8c1db6f3c6673ebda6">More...</a><br /></td></tr>
<tr class="separator:a0cd6e2dee678cb8c1db6f3c6673ebda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4955a91c2e6c56ada89eb3ca231f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a1b4955a91c2e6c56ada89eb3ca231f1a">P</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a> &amp;p) const</td></tr>
<tr class="memdesc:a1b4955a91c2e6c56ada89eb3ca231f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the block on the diagonal \(P\) in the parameter.  <a href="#a1b4955a91c2e6c56ada89eb3ca231f1a">More...</a><br /></td></tr>
<tr class="separator:a1b4955a91c2e6c56ada89eb3ca231f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a9ae5ddba128a5578b5dbca1db0d20"><td class="memItemLeft" align="right" valign="top"><a id="a94a9ae5ddba128a5578b5dbca1db0d20"></a>
<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a94a9ae5ddba128a5578b5dbca1db0d20">P</a> () const</td></tr>
<tr class="memdesc:a94a9ae5ddba128a5578b5dbca1db0d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block on the diagonal \(P\). <br /></td></tr>
<tr class="separator:a94a9ae5ddba128a5578b5dbca1db0d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5764632c511efd7fe6e9d10b8b098b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a5764632c511efd7fe6e9d10b8b098b17">Tplus</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;T, std::size_t tp, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi) const</td></tr>
<tr class="memdesc:a5764632c511efd7fe6e9d10b8b098b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the block on the lower subdiagonal \(T^{+}_{t&#39;}\) in a parameter.  <a href="#a5764632c511efd7fe6e9d10b8b098b17">More...</a><br /></td></tr>
<tr class="separator:a5764632c511efd7fe6e9d10b8b098b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb035fe45fcc912b7d078dcd27fb56c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a1eb035fe45fcc912b7d078dcd27fb56c">Tplus</a> (std::size_t tp, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi) const</td></tr>
<tr class="memdesc:a1eb035fe45fcc912b7d078dcd27fb56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block on the lower subdiagonal \(T^{+}_{t&#39;}\).  <a href="#a1eb035fe45fcc912b7d078dcd27fb56c">More...</a><br /></td></tr>
<tr class="separator:a1eb035fe45fcc912b7d078dcd27fb56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc195990fd9d023fd2012d75e68566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a9ccc195990fd9d023fd2012d75e68566">Tminus</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;T, std::size_t tp, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi) const</td></tr>
<tr class="memdesc:a9ccc195990fd9d023fd2012d75e68566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the block on the upper subdiagonal \(T^{-}_{t&#39;}\) in a parameter.  <a href="#a9ccc195990fd9d023fd2012d75e68566">More...</a><br /></td></tr>
<tr class="separator:a9ccc195990fd9d023fd2012d75e68566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9588ac9364f5a1723cc993970f8093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#afe9588ac9364f5a1723cc993970f8093">Tminus</a> (std::size_t tp, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi) const</td></tr>
<tr class="memdesc:afe9588ac9364f5a1723cc993970f8093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block on the upper subdiagonal \(T^{-}_{t&#39;}\).  <a href="#afe9588ac9364f5a1723cc993970f8093">More...</a><br /></td></tr>
<tr class="separator:afe9588ac9364f5a1723cc993970f8093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749941d7a03c7fd8d75a32e4f9be0364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a749941d7a03c7fd8d75a32e4f9be0364">Q</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;q, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi) const</td></tr>
<tr class="memdesc:a749941d7a03c7fd8d75a32e4f9be0364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the full fermion matrix \(Q\) in the parameter.  <a href="#a749941d7a03c7fd8d75a32e4f9be0364">More...</a><br /></td></tr>
<tr class="separator:a749941d7a03c7fd8d75a32e4f9be0364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a4e54d5cfb4d69a1ef089ec7633339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a04a4e54d5cfb4d69a1ef089ec7633339">Q</a> (const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi) const</td></tr>
<tr class="memdesc:a04a4e54d5cfb4d69a1ef089ec7633339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full fermion matrix.  <a href="#a04a4e54d5cfb4d69a1ef089ec7633339">More...</a><br /></td></tr>
<tr class="separator:a04a4e54d5cfb4d69a1ef089ec7633339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbec1be499ccfd93ccad2d1b34a41108"><td class="memItemLeft" align="right" valign="top"><a id="abbec1be499ccfd93ccad2d1b34a41108"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#abbec1be499ccfd93ccad2d1b34a41108">updateKappaTilde</a> (const <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a> &amp;<a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a616f6a1a413cdaa537b055ae5d8e5a7e">kappaTilde</a>)</td></tr>
<tr class="memdesc:abbec1be499ccfd93ccad2d1b34a41108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the hopping matrix. <br /></td></tr>
<tr class="separator:abbec1be499ccfd93ccad2d1b34a41108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af327e7acf6282117a17869dfde3910df"><td class="memItemLeft" align="right" valign="top"><a id="af327e7acf6282117a17869dfde3910df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#af327e7acf6282117a17869dfde3910df">updateMuTilde</a> (double <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#ad909d60ba496b017b583736fdbff926d">muTilde</a>)</td></tr>
<tr class="memdesc:af327e7acf6282117a17869dfde3910df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the chemical potential. <br /></td></tr>
<tr class="separator:af327e7acf6282117a17869dfde3910df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616f6a1a413cdaa537b055ae5d8e5a7e"><td class="memItemLeft" align="right" valign="top"><a id="a616f6a1a413cdaa537b055ae5d8e5a7e"></a>
const <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a616f6a1a413cdaa537b055ae5d8e5a7e">kappaTilde</a> () const noexcept</td></tr>
<tr class="memdesc:a616f6a1a413cdaa537b055ae5d8e5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return hopping matrix. <br /></td></tr>
<tr class="separator:a616f6a1a413cdaa537b055ae5d8e5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad909d60ba496b017b583736fdbff926d"><td class="memItemLeft" align="right" valign="top"><a id="ad909d60ba496b017b583736fdbff926d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#ad909d60ba496b017b583736fdbff926d">muTilde</a> () const noexcept</td></tr>
<tr class="memdesc:ad909d60ba496b017b583736fdbff926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return chemical potential. <br /></td></tr>
<tr class="separator:ad909d60ba496b017b583736fdbff926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd0a80c5e1109aa52fe38cb384be23f"><td class="memItemLeft" align="right" valign="top"><a id="a3bd0a80c5e1109aa52fe38cb384be23f"></a>
std::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a3bd0a80c5e1109aa52fe38cb384be23f">sigmaKappa</a> () const noexcept</td></tr>
<tr class="memdesc:a3bd0a80c5e1109aa52fe38cb384be23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sign of kappa in hole matrix. <br /></td></tr>
<tr class="separator:a3bd0a80c5e1109aa52fe38cb384be23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222e3401b30eb610449c881dd9c949cb"><td class="memItemLeft" align="right" valign="top"><a id="a222e3401b30eb610449c881dd9c949cb"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a222e3401b30eb610449c881dd9c949cb">nx</a> () const noexcept</td></tr>
<tr class="memdesc:a222e3401b30eb610449c881dd9c949cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial size of the lattice. <br /></td></tr>
<tr class="separator:a222e3401b30eb610449c881dd9c949cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a573907da84a2a87dcd54c67af96b19b1"><td class="memItemLeft" align="right" valign="top"><a id="a573907da84a2a87dcd54c67af96b19b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_invalidateKCaches</b> () noexcept</td></tr>
<tr class="separator:a573907da84a2a87dcd54c67af96b19b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a48a685670c9d91639f7422bbfa106d29"><td class="memItemLeft" align="right" valign="top"><a id="a48a685670c9d91639f7422bbfa106d29"></a>
<a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a48a685670c9d91639f7422bbfa106d29">_kappa</a></td></tr>
<tr class="memdesc:a48a685670c9d91639f7422bbfa106d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hopping matrix. <br /></td></tr>
<tr class="separator:a48a685670c9d91639f7422bbfa106d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae712c9c36933c0becbf069334a6072b1"><td class="memItemLeft" align="right" valign="top"><a id="ae712c9c36933c0becbf069334a6072b1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#ae712c9c36933c0becbf069334a6072b1">_mu</a></td></tr>
<tr class="memdesc:ae712c9c36933c0becbf069334a6072b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chemical potential. <br /></td></tr>
<tr class="separator:ae712c9c36933c0becbf069334a6072b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3198ecb03cf2ffbc1a50abad2c48c734"><td class="memItemLeft" align="right" valign="top"><a id="a3198ecb03cf2ffbc1a50abad2c48c734"></a>
std::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a3198ecb03cf2ffbc1a50abad2c48c734">_sigmaKappa</a></td></tr>
<tr class="memdesc:a3198ecb03cf2ffbc1a50abad2c48c734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign of kappa in M^dag. <br /></td></tr>
<tr class="separator:a3198ecb03cf2ffbc1a50abad2c48c734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c35834a59191f72e32dab86aff395"><td class="memItemLeft" align="right" valign="top"><a id="a367c35834a59191f72e32dab86aff395"></a>
<a class="el" href="classisle_1_1Cache.html">Cache</a>&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a>, std::function&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a>()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#a367c35834a59191f72e32dab86aff395">_kinvp</a></td></tr>
<tr class="memdesc:a367c35834a59191f72e32dab86aff395"><td class="mdescLeft">&#160;</td><td class="mdescRight">K^-1 for particles. <br /></td></tr>
<tr class="separator:a367c35834a59191f72e32dab86aff395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbce0b269b85e0ab3097f2ce9af0c172"><td class="memItemLeft" align="right" valign="top"><a id="acbce0b269b85e0ab3097f2ce9af0c172"></a>
<a class="el" href="classisle_1_1Cache.html">Cache</a>&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a>, std::function&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a>()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#acbce0b269b85e0ab3097f2ce9af0c172">_kinvh</a></td></tr>
<tr class="memdesc:acbce0b269b85e0ab3097f2ce9af0c172"><td class="mdescLeft">&#160;</td><td class="mdescRight">K^-1 for holes. <br /></td></tr>
<tr class="separator:acbce0b269b85e0ab3097f2ce9af0c172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a fermion matrix \(M\) for the Hubbard model with hopping matrix on the diagonal. </p>
<p>See <b><code>docs/algorithms/hubbardFermiAction.pdf</code></b> for definitions. All member functions of this class are named after the corresponting matrices.</p>
<p><code>HubbardFermiMatrixDia</code> needs \(\tilde{\kappa}, \phi, \tilde{\mu}, \mathrm{and}\, \sigma_\tilde{\kappa}\) as inputs and can construct the individual blocks \(K, F, P, T^{+}, \mathrm{and}\, T^{-}\) or the full matrices \(M, Q\) from them.</p>
<p>Neither the full matrix nor any of its blocks are stored explicitly. Instead, each block needs to be constructed when needed which might be expensive.</p>
<p>The result of an LU-decomposition of \(Q\) is stored in HubbardFermiMatrixDia::LU to save memory and give easier access to the components compared to a <code>blaze::Matrix</code>. The only exception are the inversed of \(K\) which are cached after when the function <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html#aae2c0163bb762f31c011274ddd528a0a" title="Return the inverse of the diagonal block matrix K of matrix M. ">HubbardFermiMatrixDia::Kinv()</a> is first called.</p>
<dl class="section see"><dt>See also</dt><dd>Free functions operating on <code>HubbardFermimatrixDia</code>:<ul>
<li>std::complex&lt;double&gt; <a class="el" href="namespaceisle.html#a60202a0e588287a9790abbebc1a2c236" title="Compute . ">logdetM(const HubbardFermiMatrixDia &amp;hfm, const CDVector &amp;phi, Species species)</a></li>
<li>HubbardFermiMatrixDia::LU <a class="el" href="namespaceisle.html#a4d77ab2b13b2b6395281572351670877" title="Perform an LU-decomposition of Q. ">getQLU(const HubbardFermiMatrixDia &amp;hfm, const CDVector &amp;phi)</a></li>
<li>std::complex&lt;double&gt; <a class="el" href="namespaceisle.html#a9066db6c1e79360f60aebaf98d8f9a06" title="Compute  by means of an LU-decomposition. ">logdetQ(const HubbardFermiMatrixDia &amp;hfm, const CDVector &amp;phi)</a></li>
<li>std::complex&lt;double&gt; <a class="el" href="namespaceisle.html#ad41c26226f421b25ffd6854519717590" title="Compute  given an LU-decomposition. ">logdetQ(const HubbardFermiMatrixDia::QLU &amp;lu)</a></li>
<li><a class="el" href="namespaceisle.html#aeba575f1a9fca51f95d20e44b7b7be7b" title="A generic dense vector. ">Vector</a>&lt;std::complex&lt;double&gt;&gt; <a class="el" href="namespaceisle.html#a7dde3d243fe78b2d89ffc5a14b6e50b7" title="Solve a system of equations . ">solveQ(const HubbardFermiMatrixDia &amp;hfm, const CDVector &amp;phi, const Vector&lt;std::complex&lt;double&gt;&gt; &amp;rhs)</a>;</li>
<li><a class="el" href="namespaceisle.html#aeba575f1a9fca51f95d20e44b7b7be7b" title="A generic dense vector. ">Vector</a>&lt;std::complex&lt;double&gt;&gt; <a class="el" href="namespaceisle.html#a41fa5d40004f3689355f7d48f2270833" title="Solve a system of equations ; use LU-decomposition directly. ">solveQ(const HubbardFermiMatrixDia::QLU &amp;lu, const Vector&lt;std::complex&lt;double&gt;&gt; &amp;rhs)</a>;</li>
</ul>
</dd></dl>
<p>See <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html" title="Represents a fermion matrix  for the Hubbard model with hopping matrix in an exponential. ">HubbardFermiMatrixExp</a> for an alternative discretization. </p>

<p class="definition">Definition at line <a class="el" href="hubbardFermiMatrixDia_8hpp_source.html#l00048">48</a> of file <a class="el" href="hubbardFermiMatrixDia_8hpp_source.html">hubbardFermiMatrixDia.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39e0ea48aee7f69ae6c81181fc730909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e0ea48aee7f69ae6c81181fc730909">&#9670;&nbsp;</a></span>HubbardFermiMatrixDia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isle::HubbardFermiMatrixDia::HubbardFermiMatrixDia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>kappaTilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>muTilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int8_t&#160;</td>
          <td class="paramname"><em>sigmaKappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store all necessary parameters to later construct the full fermion matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kappaTile</td><td>Hopping matrix \(\tilde{\kappa}\). </td></tr>
    <tr><td class="paramname">muTilde</td><td>Chemical potential \(\tilde{\mu}\). </td></tr>
    <tr><td class="paramname">sigmaKappa</td><td>Sign of hopping matrix in hole matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a32039da45c62a79868918b0d5fc47011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32039da45c62a79868918b0d5fc47011">&#9670;&nbsp;</a></span>F() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isle::HubbardFermiMatrixDia::F </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store an off-diagonal block F of matrix M in the parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Any old content is erased and the matrix is resized if need be. </td></tr>
    <tr><td class="paramname">tp</td><td>Temporal row index t'. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to construct for particles or holes. </td></tr>
    <tr><td class="paramname">inv</td><td>If <code>true</code> constructs the inverse of F. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59c2cb52fa57fee1de71d36aec4570c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c2cb52fa57fee1de71d36aec4570c3">&#9670;&nbsp;</a></span>F() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> isle::HubbardFermiMatrixDia::F </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an off-diagonal block matrix F of matrix M. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>Temporal row index t'. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to construct for particles or holes. </td></tr>
    <tr><td class="paramname">inv</td><td>If <code>true</code> constructs the inverse of F. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1951da2a77107d06560c83fa65a22b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951da2a77107d06560c83fa65a22b1e">&#9670;&nbsp;</a></span>K() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isle::HubbardFermiMatrixDia::K </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the diagonal block K of matrix M in the parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Any old content is erased and the matrix is resized if need be. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to construct for particles or holes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefe8aa1a749e01483c9be5056fa9d191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe8aa1a749e01483c9be5056fa9d191">&#9670;&nbsp;</a></span>K() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a> isle::HubbardFermiMatrixDia::K </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the diagonal block matrix K of matrix M. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">species</td><td>Select whether to construct for particles or holes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae2c0163bb762f31c011274ddd528a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2c0163bb762f31c011274ddd528a0a">&#9670;&nbsp;</a></span>Kinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a>&amp; isle::HubbardFermiMatrixDia::Kinv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the inverse of the diagonal block matrix K of matrix M. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">species</td><td>Select whether to construct for particles or holes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0ee41a7290eabe1e8e2e5cddae6d37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ee41a7290eabe1e8e2e5cddae6d37f">&#9670;&nbsp;</a></span>M() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isle::HubbardFermiMatrixDia::M </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the matrix \(M\) in the parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Any old content is erased and the matrix is resized if need be. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to construct for particles or holes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cd6e2dee678cb8c1db6f3c6673ebda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd6e2dee678cb8c1db6f3c6673ebda6">&#9670;&nbsp;</a></span>M() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> isle::HubbardFermiMatrixDia::M </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the matrix \(M\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to construct for particles or holes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b4955a91c2e6c56ada89eb3ca231f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4955a91c2e6c56ada89eb3ca231f1a">&#9670;&nbsp;</a></span>P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isle::HubbardFermiMatrixDia::P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">DSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the block on the diagonal \(P\) in the parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Block on the diagonal. Any old content is erased and the matrix is resized if need be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a749941d7a03c7fd8d75a32e4f9be0364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749941d7a03c7fd8d75a32e4f9be0364">&#9670;&nbsp;</a></span>Q() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isle::HubbardFermiMatrixDia::Q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the full fermion matrix \(Q\) in the parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Full fermion matrix. Any old content is erased and the matrix is resized if need be. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04a4e54d5cfb4d69a1ef089ec7633339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a4e54d5cfb4d69a1ef089ec7633339">&#9670;&nbsp;</a></span>Q() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> isle::HubbardFermiMatrixDia::Q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the full fermion matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ccc195990fd9d023fd2012d75e68566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccc195990fd9d023fd2012d75e68566">&#9670;&nbsp;</a></span>Tminus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isle::HubbardFermiMatrixDia::Tminus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the block on the upper subdiagonal \(T^{-}_{t&#39;}\) in a parameter. </p>
<p>Applies anti periodic boundary conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Block on the upper subdiagonal. Any old content is erased and the matrix is resized if need be. </td></tr>
    <tr><td class="paramname">tp</td><td>Temporal row index \(t&#39;\). </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe9588ac9364f5a1723cc993970f8093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9588ac9364f5a1723cc993970f8093">&#9670;&nbsp;</a></span>Tminus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> isle::HubbardFermiMatrixDia::Tminus </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the block on the upper subdiagonal \(T^{-}_{t&#39;}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>Temporal row index \(t&#39;\). </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5764632c511efd7fe6e9d10b8b098b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5764632c511efd7fe6e9d10b8b098b17">&#9670;&nbsp;</a></span>Tplus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isle::HubbardFermiMatrixDia::Tplus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the block on the lower subdiagonal \(T^{+}_{t&#39;}\) in a parameter. </p>
<p>Applies anti periodic boundary conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Block on the lower subdiagonal. Any old content is erased and the matrix is resized if need be. </td></tr>
    <tr><td class="paramname">tp</td><td>Temporal row index \(t&#39;\). </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1eb035fe45fcc912b7d078dcd27fb56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb035fe45fcc912b7d078dcd27fb56c">&#9670;&nbsp;</a></span>Tplus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">CDSparseMatrix</a> isle::HubbardFermiMatrixDia::Tplus </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the block on the lower subdiagonal \(T^{+}_{t&#39;}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>Temporal row index \(t&#39;\). </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/jl-wynen/isle/src/isle/cpp/<a class="el" href="hubbardFermiMatrixDia_8hpp_source.html">hubbardFermiMatrixDia.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceisle.html">isle</a></li><li class="navelem"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
