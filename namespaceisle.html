<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>isle: isle Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">isle
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">Lattice Monte Carlo for Carbon Nanostructures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceisle.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">isle Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base Python package of isle.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceisle_1_1action"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1action.html">action</a></td></tr>
<tr class="memdesc:namespaceisle_1_1action"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all actions implemented in C++. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1checks"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1checks.html">checks</a></td></tr>
<tr class="memdesc:namespaceisle_1_1checks"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various basic checks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1cpp__wrappers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1cpp__wrappers.html">cpp_wrappers</a></td></tr>
<tr class="memdesc:namespaceisle_1_1cpp__wrappers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import C++ extension. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1drivers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1drivers.html">drivers</a></td></tr>
<tr class="memdesc:namespaceisle_1_1drivers"><td class="mdescLeft">&#160;</td><td class="mdescRight">High level drivers to build user scripts. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1fileio"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1fileio.html">fileio</a></td></tr>
<tr class="memdesc:namespaceisle_1_1fileio"><td class="mdescLeft">&#160;</td><td class="mdescRight">General file input / output. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1meas"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1meas.html">meas</a></td></tr>
<tr class="memdesc:namespaceisle_1_1meas"><td class="mdescLeft">&#160;</td><td class="mdescRight">General measurements that can be useful in various contexts. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1random.html">random</a></td></tr>
<tr class="memdesc:namespaceisle_1_1random"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for random number generators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1tmp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1tmp.html">tmp</a></td></tr>
<tr class="memdesc:namespaceisle_1_1tmp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template meta programming. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceisle_1_1yamlio"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle_1_1yamlio.html">yamlio</a></td></tr>
<tr class="memdesc:namespaceisle_1_1yamlio"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines for YAML IO. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1Cache.html">Cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object on demand and memoize it.  <a href="classisle_1_1Cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1ElementType.html">ElementType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element type of a linear algebra type (vector, matrix).  <a href="structisle_1_1ElementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1ElementType_3_01blaze_1_1CompressedMatrix_3_01ET_00_01TF_01_4_01_4.html">ElementType&lt; blaze::CompressedMatrix&lt; ET, TF &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for blaze::SparseMatrix.  <a href="structisle_1_1ElementType_3_01blaze_1_1CompressedMatrix_3_01ET_00_01TF_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1ElementType_3_01blaze_1_1DynamicMatrix_3_01ET_00_01TF_01_4_01_4.html">ElementType&lt; blaze::DynamicMatrix&lt; ET, TF &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for blaze::DynamicMatrix.  <a href="structisle_1_1ElementType_3_01blaze_1_1DynamicMatrix_3_01ET_00_01TF_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1ElementType_3_01blaze_1_1DynamicVector_3_01ET_00_01TF_01_4_01_4.html">ElementType&lt; blaze::DynamicVector&lt; ET, TF &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for blaze::DynamicVector.  <a href="structisle_1_1ElementType_3_01blaze_1_1DynamicVector_3_01ET_00_01TF_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1ElementType_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__arithmetic_3_01T_01_4_190f412b3266e02c01e688ac6bac26736.html">ElementType&lt; T, std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value||tmp::IsSpecialization&lt; std::complex, T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for arithmetic types and std::complex.  <a href="structisle_1_1ElementType_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__arithmetic_3_01T_01_4_190f412b3266e02c01e688ac6bac26736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a fermion matrix \(M\) for the Hubbard model with hopping matrix on the diagonal.  <a href="classisle_1_1HubbardFermiMatrixDia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a fermion matrix \(\hat{M}\) for the Hubbard model with hopping matrix in an exponential.  <a href="classisle_1_1HubbardFermiMatrixExp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1Lattice.html">Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a spacetime lattice.  <a href="classisle_1_1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisle_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Python's logging interface.  <a href="classisle_1_1Logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1PointerFlagPair.html">PointerFlagPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hold a pointer and a flag in one piece of memory.  <a href="structisle_1_1PointerFlagPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid of unique and observer pointer.  <a href="structisle_1_1UnObHybridPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1ValueType.html">ValueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value type from a given compound type.  <a href="structisle_1_1ValueType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1ValueType_3_01std_1_1complex_3_01T_01_4_01_4.html">ValueType&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::complex.  <a href="structisle_1_1ValueType_3_01std_1_1complex_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeba575f1a9fca51f95d20e44b7b7be7b"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:aeba575f1a9fca51f95d20e44b7b7be7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#aeba575f1a9fca51f95d20e44b7b7be7b">Vector</a> = blaze::DynamicVector&lt; ET &gt;</td></tr>
<tr class="memdesc:aeba575f1a9fca51f95d20e44b7b7be7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic dense vector.  <a href="#aeba575f1a9fca51f95d20e44b7b7be7b">More...</a><br /></td></tr>
<tr class="separator:aeba575f1a9fca51f95d20e44b7b7be7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fce59b2cdee49d5429139c0682806f"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:a07fce59b2cdee49d5429139c0682806f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a07fce59b2cdee49d5429139c0682806f">Vec3</a> = blaze::StaticVector&lt; ET, 3 &gt;</td></tr>
<tr class="memdesc:a07fce59b2cdee49d5429139c0682806f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds spatial coordinates.  <a href="#a07fce59b2cdee49d5429139c0682806f">More...</a><br /></td></tr>
<tr class="separator:a07fce59b2cdee49d5429139c0682806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9509585ef7b40afb903b7d621a2a1f"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:abd9509585ef7b40afb903b7d621a2a1f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#abd9509585ef7b40afb903b7d621a2a1f">Matrix</a> = blaze::DynamicMatrix&lt; ET &gt;</td></tr>
<tr class="memdesc:abd9509585ef7b40afb903b7d621a2a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic dense matrix.  <a href="#abd9509585ef7b40afb903b7d621a2a1f">More...</a><br /></td></tr>
<tr class="separator:abd9509585ef7b40afb903b7d621a2a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addeb55864856a65fe3923ff9c9e9ac0e"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:addeb55864856a65fe3923ff9c9e9ac0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#addeb55864856a65fe3923ff9c9e9ac0e">SparseMatrix</a> = blaze::CompressedMatrix&lt; ET &gt;</td></tr>
<tr class="memdesc:addeb55864856a65fe3923ff9c9e9ac0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic sparse matrix.  <a href="#addeb55864856a65fe3923ff9c9e9ac0e">More...</a><br /></td></tr>
<tr class="separator:addeb55864856a65fe3923ff9c9e9ac0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b52b733211e398e6bc2005b717de23"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:af0b52b733211e398e6bc2005b717de23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#af0b52b733211e398e6bc2005b717de23">IdMatrix</a> = blaze::IdentityMatrix&lt; ET &gt;</td></tr>
<tr class="memdesc:af0b52b733211e398e6bc2005b717de23"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identity matrix.  <a href="#af0b52b733211e398e6bc2005b717de23">More...</a><br /></td></tr>
<tr class="separator:af0b52b733211e398e6bc2005b717de23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b19574e84eff5030192d6e5a26c0056"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:a2b19574e84eff5030192d6e5a26c0056"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a2b19574e84eff5030192d6e5a26c0056">SymmetricMatrix</a> = blaze::SymmetricMatrix&lt; blaze::DynamicMatrix&lt; ET &gt; &gt;</td></tr>
<tr class="memdesc:a2b19574e84eff5030192d6e5a26c0056"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic symmetric dense matrix.  <a href="#a2b19574e84eff5030192d6e5a26c0056">More...</a><br /></td></tr>
<tr class="separator:a2b19574e84eff5030192d6e5a26c0056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b21648e9a7853156b931a081760fa9"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:ab6b21648e9a7853156b931a081760fa9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ab6b21648e9a7853156b931a081760fa9">SymmetricSparseMatrix</a> = blaze::SymmetricMatrix&lt; blaze::CompressedMatrix&lt; ET &gt; &gt;</td></tr>
<tr class="memdesc:ab6b21648e9a7853156b931a081760fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic symmetric sparse matrix.  <a href="#ab6b21648e9a7853156b931a081760fa9">More...</a><br /></td></tr>
<tr class="separator:ab6b21648e9a7853156b931a081760fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70ca8f1c41c31c81cb4d295b4553eb6"><td class="memItemLeft" align="right" valign="top"><a id="ad70ca8f1c41c31c81cb4d295b4553eb6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IVector</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; int &gt;</td></tr>
<tr class="separator:ad70ca8f1c41c31c81cb4d295b4553eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c31be69f073e24e1a31ef9f05668527"><td class="memItemLeft" align="right" valign="top"><a id="a2c31be69f073e24e1a31ef9f05668527"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DVector</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; double &gt;</td></tr>
<tr class="separator:a2c31be69f073e24e1a31ef9f05668527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd5c2e51ba9454b28ed06faa00609b"><td class="memItemLeft" align="right" valign="top"><a id="a08cd5c2e51ba9454b28ed06faa00609b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CDVector</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;</td></tr>
<tr class="separator:a08cd5c2e51ba9454b28ed06faa00609b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3deb7edb4fa41bc9339131e91f5c95"><td class="memItemLeft" align="right" valign="top"><a id="ade3deb7edb4fa41bc9339131e91f5c95"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IMatrix</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">Matrix</a>&lt; int &gt;</td></tr>
<tr class="separator:ade3deb7edb4fa41bc9339131e91f5c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa74134cb079c62db7f102b7e1cb462"><td class="memItemLeft" align="right" valign="top"><a id="a4aa74134cb079c62db7f102b7e1cb462"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DMatrix</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">Matrix</a>&lt; double &gt;</td></tr>
<tr class="separator:a4aa74134cb079c62db7f102b7e1cb462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0303fbcb6dfa8fea3e261636eaf303e"><td class="memItemLeft" align="right" valign="top"><a id="ad0303fbcb6dfa8fea3e261636eaf303e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CDMatrix</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">Matrix</a>&lt; std::complex&lt; double &gt; &gt;</td></tr>
<tr class="separator:ad0303fbcb6dfa8fea3e261636eaf303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a9918f3efff7b915f261ddf53661eb"><td class="memItemLeft" align="right" valign="top"><a id="af1a9918f3efff7b915f261ddf53661eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ISparseMatrix</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; int &gt;</td></tr>
<tr class="separator:af1a9918f3efff7b915f261ddf53661eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ac9d485e6629c49f6d9ecd886842ac"><td class="memItemLeft" align="right" valign="top"><a id="a47ac9d485e6629c49f6d9ecd886842ac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DSparseMatrix</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; double &gt;</td></tr>
<tr class="separator:a47ac9d485e6629c49f6d9ecd886842ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d31f239d7144af17a41e7cd68c21ab"><td class="memItemLeft" align="right" valign="top"><a id="ab0d31f239d7144af17a41e7cd68c21ab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CDSparseMatrix</b> = <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; std::complex&lt; double &gt; &gt;</td></tr>
<tr class="separator:ab0d31f239d7144af17a41e7cd68c21ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582cb86f0774a8d07a1a44e2a68dab4e"><td class="memTemplParams" colspan="2"><a id="a582cb86f0774a8d07a1a44e2a68dab4e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a582cb86f0774a8d07a1a44e2a68dab4e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a582cb86f0774a8d07a1a44e2a68dab4e">ValueType_t</a> = typename <a class="el" href="structisle_1_1ValueType.html">ValueType</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a582cb86f0774a8d07a1a44e2a68dab4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for <a class="el" href="structisle_1_1ValueType.html" title="Get the value type from a given compound type. ">ValueType</a>. <br /></td></tr>
<tr class="separator:a582cb86f0774a8d07a1a44e2a68dab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd458b34a1cf89192ffb0f38bcc0f88"><td class="memTemplParams" colspan="2"><a id="acdd458b34a1cf89192ffb0f38bcc0f88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdd458b34a1cf89192ffb0f38bcc0f88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#acdd458b34a1cf89192ffb0f38bcc0f88">ElementType_t</a> = typename <a class="el" href="structisle_1_1ElementType.html">ElementType</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:acdd458b34a1cf89192ffb0f38bcc0f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for <a class="el" href="structisle_1_1ElementType.html" title="Get the element type of a linear algebra type (vector, matrix). ">ElementType</a>. <br /></td></tr>
<tr class="separator:acdd458b34a1cf89192ffb0f38bcc0f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa6202a7db432da01e9790291956ec778"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> { <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778a5818992261344f3f6c810ea0dfc13c24">Species::PARTICLE</a>, 
<a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778aadec9358cd14fbdcdb29c5b2f040d712">Species::HOLE</a>
 }<tr class="memdesc:aa6202a7db432da01e9790291956ec778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark particles and holes.  <a href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa6202a7db432da01e9790291956ec778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4b36be9317900433e26eaa00b7237cb7"><td class="memItemLeft" align="right" valign="top"><a id="a4b36be9317900433e26eaa00b7237cb7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (args, kwargs)</td></tr>
<tr class="separator:a4b36be9317900433e26eaa00b7237cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996b893098ab4040b6a2128c370750b8"><td class="memTemplParams" colspan="2"><a id="a996b893098ab4040b6a2128c370750b8"></a>
template&lt;typename GT , typename... ItemArgs&gt; </td></tr>
<tr class="memitem:a996b893098ab4040b6a2128c370750b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a996b893098ab4040b6a2128c370750b8">makeCache</a> (GT &amp;&amp;gen, ItemArgs &amp;&amp;...itemArgs)</td></tr>
<tr class="memdesc:a996b893098ab4040b6a2128c370750b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new cache with given generator and constructs the item with given arguments. <br /></td></tr>
<tr class="separator:a996b893098ab4040b6a2128c370750b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d77ab2b13b2b6395281572351670877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a4d77ab2b13b2b6395281572351670877">getQLU</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi)</td></tr>
<tr class="memdesc:a4d77ab2b13b2b6395281572351670877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an LU-decomposition of Q.  <a href="#a4d77ab2b13b2b6395281572351670877">More...</a><br /></td></tr>
<tr class="separator:a4d77ab2b13b2b6395281572351670877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dde3d243fe78b2d89ffc5a14b6e50b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a7dde3d243fe78b2d89ffc5a14b6e50b7">solveQ</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7dde3d243fe78b2d89ffc5a14b6e50b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations \(Q x = b\).  <a href="#a7dde3d243fe78b2d89ffc5a14b6e50b7">More...</a><br /></td></tr>
<tr class="separator:a7dde3d243fe78b2d89ffc5a14b6e50b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fa5d40004f3689355f7d48f2270833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a41fa5d40004f3689355f7d48f2270833">solveQ</a> (const <a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a> &amp;lu, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a41fa5d40004f3689355f7d48f2270833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations \(Q x = b\); use LU-decomposition directly.  <a href="#a41fa5d40004f3689355f7d48f2270833">More...</a><br /></td></tr>
<tr class="separator:a41fa5d40004f3689355f7d48f2270833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9066db6c1e79360f60aebaf98d8f9a06"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a9066db6c1e79360f60aebaf98d8f9a06">logdetQ</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi)</td></tr>
<tr class="memdesc:a9066db6c1e79360f60aebaf98d8f9a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(Q))\) by means of an LU-decomposition.  <a href="#a9066db6c1e79360f60aebaf98d8f9a06">More...</a><br /></td></tr>
<tr class="separator:a9066db6c1e79360f60aebaf98d8f9a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41c26226f421b25ffd6854519717590"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ad41c26226f421b25ffd6854519717590">logdetQ</a> (const <a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a> &amp;lu)</td></tr>
<tr class="memdesc:ad41c26226f421b25ffd6854519717590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(Q))\) given an LU-decomposition.  <a href="#ad41c26226f421b25ffd6854519717590">More...</a><br /></td></tr>
<tr class="separator:ad41c26226f421b25ffd6854519717590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7be0174cb3bd2485fc5d9424898bc9e"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ae7be0174cb3bd2485fc5d9424898bc9e">ilogdetQ</a> (<a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a> &amp;lu)</td></tr>
<tr class="memdesc:ae7be0174cb3bd2485fc5d9424898bc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(Q))\) given an LU-decomposition, overwrites input.  <a href="#ae7be0174cb3bd2485fc5d9424898bc9e">More...</a><br /></td></tr>
<tr class="separator:ae7be0174cb3bd2485fc5d9424898bc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60202a0e588287a9790abbebc1a2c236"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a60202a0e588287a9790abbebc1a2c236">logdetM</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species)</td></tr>
<tr class="memdesc:a60202a0e588287a9790abbebc1a2c236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(M))\).  <a href="#a60202a0e588287a9790abbebc1a2c236">More...</a><br /></td></tr>
<tr class="separator:a60202a0e588287a9790abbebc1a2c236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac677ca134acbf8dcc9d9b6ba1301a797"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ac677ca134acbf8dcc9d9b6ba1301a797">solveM</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species, const std::vector&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac677ca134acbf8dcc9d9b6ba1301a797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations \(M x = b\).  <a href="#ac677ca134acbf8dcc9d9b6ba1301a797">More...</a><br /></td></tr>
<tr class="separator:ac677ca134acbf8dcc9d9b6ba1301a797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d467ddef5485f5f264cf443a021710a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a0d467ddef5485f5f264cf443a021710a">getQLU</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi)</td></tr>
<tr class="memdesc:a0d467ddef5485f5f264cf443a021710a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an LU-decomposition of Q.  <a href="#a0d467ddef5485f5f264cf443a021710a">More...</a><br /></td></tr>
<tr class="separator:a0d467ddef5485f5f264cf443a021710a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4022f16195fbda9ab98d20b0b509231a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a4022f16195fbda9ab98d20b0b509231a">solveQ</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4022f16195fbda9ab98d20b0b509231a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations \(Q x = b\).  <a href="#a4022f16195fbda9ab98d20b0b509231a">More...</a><br /></td></tr>
<tr class="separator:a4022f16195fbda9ab98d20b0b509231a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0145ecf781dd4852f8bfa3fcb6efbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a8f0145ecf781dd4852f8bfa3fcb6efbb">solveQ</a> (const <a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a> &amp;lu, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8f0145ecf781dd4852f8bfa3fcb6efbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations \(Q x = b\); use LU-decomposition directly.  <a href="#a8f0145ecf781dd4852f8bfa3fcb6efbb">More...</a><br /></td></tr>
<tr class="separator:a8f0145ecf781dd4852f8bfa3fcb6efbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8e05e885d8217bd60bb5f3c904846d"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a4f8e05e885d8217bd60bb5f3c904846d">logdetQ</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi)</td></tr>
<tr class="memdesc:a4f8e05e885d8217bd60bb5f3c904846d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(Q))\) by means of an LU-decomposition.  <a href="#a4f8e05e885d8217bd60bb5f3c904846d">More...</a><br /></td></tr>
<tr class="separator:a4f8e05e885d8217bd60bb5f3c904846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5088489ec500cd2b3a70008c0d7fb60"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ac5088489ec500cd2b3a70008c0d7fb60">logdetQ</a> (const <a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a> &amp;lu)</td></tr>
<tr class="memdesc:ac5088489ec500cd2b3a70008c0d7fb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(Q))\) given an LU-decomposition.  <a href="#ac5088489ec500cd2b3a70008c0d7fb60">More...</a><br /></td></tr>
<tr class="separator:ac5088489ec500cd2b3a70008c0d7fb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b767734dee418ac317ba832189f9819"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a5b767734dee418ac317ba832189f9819">ilogdetQ</a> (<a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a> &amp;lu)</td></tr>
<tr class="memdesc:a5b767734dee418ac317ba832189f9819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(Q))\) given an LU-decomposition, overwrites input.  <a href="#a5b767734dee418ac317ba832189f9819">More...</a><br /></td></tr>
<tr class="separator:a5b767734dee418ac317ba832189f9819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bd52f1a60dd9c0c85b8aecb73bac2f"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a96bd52f1a60dd9c0c85b8aecb73bac2f">logdetM</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species)</td></tr>
<tr class="memdesc:a96bd52f1a60dd9c0c85b8aecb73bac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\log(\det(M))\).  <a href="#a96bd52f1a60dd9c0c85b8aecb73bac2f">More...</a><br /></td></tr>
<tr class="separator:a96bd52f1a60dd9c0c85b8aecb73bac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8229849169bc8e79c60383c6989f68"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a1e8229849169bc8e79c60383c6989f68">solveM</a> (const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;hfm, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a> species, const std::vector&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1e8229849169bc8e79c60383c6989f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a system of equations \(M x = b\).  <a href="#a1e8229849169bc8e79c60383c6989f68">More...</a><br /></td></tr>
<tr class="separator:a1e8229849169bc8e79c60383c6989f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5c260b13a36257088e0fa775d84ff2"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a>, <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a>, std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a7f5c260b13a36257088e0fa775d84ff2">leapfrog</a> (const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;phi, const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;<a class="el" href="namespaceisle.html#a83b6bc669bc5ea7ffc1c64fe2ae77e6b">pi</a>, const <a class="el" href="structisle_1_1action_1_1Action.html">action::Action</a> *action, double length, std::size_t nsteps, double direction=+1)</td></tr>
<tr class="memdesc:a7f5c260b13a36257088e0fa775d84ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform leapfrog integration.  <a href="#a7f5c260b13a36257088e0fa775d84ff2">More...</a><br /></td></tr>
<tr class="separator:a7f5c260b13a36257088e0fa775d84ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63e604357441025a3a439f4c8d35c9b"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#af63e604357441025a3a439f4c8d35c9b">loopIdx</a> (const std::size_t i, const std::size_t n) noexcept(<a class="el" href="core_8hpp.html#a738cdb227d669af6de7c465bd4917ffc">ndebug</a>)</td></tr>
<tr class="memdesc:af63e604357441025a3a439f4c8d35c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop index around boundary.  <a href="#af63e604357441025a3a439f4c8d35c9b">More...</a><br /></td></tr>
<tr class="separator:af63e604357441025a3a439f4c8d35c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65549070867f7066df6743f742447b88"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a65549070867f7066df6743f742447b88">spacetimeCoord</a> (const std::size_t x, const std::size_t t, const std::size_t nx, const std::size_t <a class="el" href="core_8hpp.html#a86d500a34c624c2cae56bc25a31b12f3">UNUSED</a>(nt)) noexcept</td></tr>
<tr class="memdesc:a65549070867f7066df6743f742447b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flat spacetime coordinate for a given pair of space and time coordinates.  <a href="#a65549070867f7066df6743f742447b88">More...</a><br /></td></tr>
<tr class="separator:a65549070867f7066df6743f742447b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d72983170e44db6950b041426dcfa7c"><td class="memItemLeft" align="right" valign="top"><a id="a6d72983170e44db6950b041426dcfa7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a6d72983170e44db6950b041426dcfa7c">isBipartite</a> (const <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; double &gt; &amp;hoppingMatrix)</td></tr>
<tr class="memdesc:a6d72983170e44db6950b041426dcfa7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if hopping matrix is bipartite, false otherwise. <br /></td></tr>
<tr class="separator:a6d72983170e44db6950b041426dcfa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91aa61f7d84b8faa788b2436c53c4ff"><td class="memItemLeft" align="right" valign="top"><a id="aa91aa61f7d84b8faa788b2436c53c4ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#aa91aa61f7d84b8faa788b2436c53c4ff">isBipartite</a> (const <a class="el" href="classisle_1_1Lattice.html">Lattice</a> &amp;lat)</td></tr>
<tr class="memdesc:aa91aa61f7d84b8faa788b2436c53c4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if hopping matrix of lat is bipartite, false otherwise. <br /></td></tr>
<tr class="separator:aa91aa61f7d84b8faa788b2436c53c4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4528b02fe90b03b536ccab2b58a1cc70"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a4528b02fe90b03b536ccab2b58a1cc70"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a4528b02fe90b03b536ccab2b58a1cc70">getNt</a> (const VT &amp;stVec, const std::size_t nx) noexcept(<a class="el" href="core_8hpp.html#a738cdb227d669af6de7c465bd4917ffc">ndebug</a>)</td></tr>
<tr class="memdesc:a4528b02fe90b03b536ccab2b58a1cc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute temporal lattice size from a spacetime vector and spatial lattice size.  <a href="#a4528b02fe90b03b536ccab2b58a1cc70">More...</a><br /></td></tr>
<tr class="separator:a4528b02fe90b03b536ccab2b58a1cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12355b2cfc109da544e1015b954239c2"><td class="memTemplParams" colspan="2"><a id="a12355b2cfc109da544e1015b954239c2"></a>
template&lt;typename RT &gt; </td></tr>
<tr class="memitem:a12355b2cfc109da544e1015b954239c2"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; RT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a12355b2cfc109da544e1015b954239c2">toFirstLogBranch</a> (const std::complex&lt; RT &gt; &amp;x)</td></tr>
<tr class="memdesc:a12355b2cfc109da544e1015b954239c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a complex number to the first branch of the logarithm (-pi, pi]. <br /></td></tr>
<tr class="separator:a12355b2cfc109da544e1015b954239c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac034705c5cc245e04fd5b9ec0d6888a8"><td class="memTemplParams" colspan="2"><a id="ac034705c5cc245e04fd5b9ec0d6888a8"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac034705c5cc245e04fd5b9ec0d6888a8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ac034705c5cc245e04fd5b9ec0d6888a8">spacevec</a> (VT &amp;&amp;vec, const std::size_t t, const std::size_t nx) noexcept(<a class="el" href="core_8hpp.html#a738cdb227d669af6de7c465bd4917ffc">ndebug</a>)</td></tr>
<tr class="memdesc:ac034705c5cc245e04fd5b9ec0d6888a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view on a spatial vector for given timeslice of a spacetime vector. <br /></td></tr>
<tr class="separator:ac034705c5cc245e04fd5b9ec0d6888a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0703680cdfbf1965a96f1d510c52aaa6"><td class="memTemplParams" colspan="2"><a id="a0703680cdfbf1965a96f1d510c52aaa6"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a0703680cdfbf1965a96f1d510c52aaa6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a0703680cdfbf1965a96f1d510c52aaa6">spacemat</a> (MT &amp;&amp;mat, const std::size_t tp, const std::size_t t, const std::size_t nx) noexcept(<a class="el" href="core_8hpp.html#a738cdb227d669af6de7c465bd4917ffc">ndebug</a>)</td></tr>
<tr class="memdesc:a0703680cdfbf1965a96f1d510c52aaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view on a spatial matrix for given timeslices of a spacetime matrix. <br /></td></tr>
<tr class="separator:a0703680cdfbf1965a96f1d510c52aaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59568c034bfdc0de9961737fdeaece7b"><td class="memTemplParams" colspan="2">template&lt;typename ET &gt; </td></tr>
<tr class="memitem:a59568c034bfdc0de9961737fdeaece7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a59568c034bfdc0de9961737fdeaece7b">invert</a> (<a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">Matrix</a>&lt; ET &gt; &amp;mat, std::unique_ptr&lt; int[]&gt; &amp;ipiv)</td></tr>
<tr class="memdesc:a59568c034bfdc0de9961737fdeaece7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a matrix in place.  <a href="#a59568c034bfdc0de9961737fdeaece7b">More...</a><br /></td></tr>
<tr class="separator:a59568c034bfdc0de9961737fdeaece7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fc6f25000755b7f7b380a8f34a7174"><td class="memTemplParams" colspan="2"><a id="a94fc6f25000755b7f7b380a8f34a7174"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a94fc6f25000755b7f7b380a8f34a7174"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a94fc6f25000755b7f7b380a8f34a7174">isInvertible</a> (MT mat, const double eps=1e-15)</td></tr>
<tr class="memdesc:a94fc6f25000755b7f7b380a8f34a7174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute eigenvalues to check whether a matrix is invertible. <br /></td></tr>
<tr class="separator:a94fc6f25000755b7f7b380a8f34a7174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdd5669e340a86c44fc642cc56e1320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#aabdd5669e340a86c44fc642cc56e1320">expmSym</a> (const <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a> &amp;mat)</td></tr>
<tr class="memdesc:aabdd5669e340a86c44fc642cc56e1320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix exponential of real, symmetrix matrices.  <a href="#aabdd5669e340a86c44fc642cc56e1320">More...</a><br /></td></tr>
<tr class="separator:aabdd5669e340a86c44fc642cc56e1320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3ae170903a6278f447f8432787f3bb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a2b3ae170903a6278f447f8432787f3bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a2b3ae170903a6278f447f8432787f3bb">ilogdet</a> (MT &amp;matrix)</td></tr>
<tr class="memdesc:a2b3ae170903a6278f447f8432787f3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logarithm of the determinant of a dense matrix; overwrites the input.  <a href="#a2b3ae170903a6278f447f8432787f3bb">More...</a><br /></td></tr>
<tr class="separator:a2b3ae170903a6278f447f8432787f3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f90a990358afa056acf6efd8ec7356"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ad4f90a990358afa056acf6efd8ec7356"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ad4f90a990358afa056acf6efd8ec7356">logdet</a> (const MT &amp;matrix)</td></tr>
<tr class="memdesc:ad4f90a990358afa056acf6efd8ec7356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logarithm of the determinant of a dense matrix.  <a href="#ad4f90a990358afa056acf6efd8ec7356">More...</a><br /></td></tr>
<tr class="separator:ad4f90a990358afa056acf6efd8ec7356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1ce2adde40ac0bf15b3e4c25c31bb5"><td class="memTemplParams" colspan="2"><a id="aca1ce2adde40ac0bf15b3e4c25c31bb5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca1ce2adde40ac0bf15b3e4c25c31bb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#aca1ce2adde40ac0bf15b3e4c25c31bb5">swap</a> (<a class="el" href="structisle_1_1PointerFlagPair.html">PointerFlagPair</a>&lt; T &gt; &amp;lhs, <a class="el" href="structisle_1_1PointerFlagPair.html">PointerFlagPair</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aca1ce2adde40ac0bf15b3e4c25c31bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two PointerFlagPairs. <br /></td></tr>
<tr class="separator:aca1ce2adde40ac0bf15b3e4c25c31bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1108a51a97a1af2379bf8ceeaf3fb6"><td class="memTemplParams" colspan="2"><a id="a2e1108a51a97a1af2379bf8ceeaf3fb6"></a>
template&lt;typename ET &gt; </td></tr>
<tr class="memitem:a2e1108a51a97a1af2379bf8ceeaf3fb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a2e1108a51a97a1af2379bf8ceeaf3fb6">swap</a> (<a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a>&lt; ET &gt; &amp;lhs, <a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a>&lt; ET &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2e1108a51a97a1af2379bf8ceeaf3fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two UnObHybridPtrs. <br /></td></tr>
<tr class="separator:a2e1108a51a97a1af2379bf8ceeaf3fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04b4c3bc93adfb9c3cfaf866bc13d55"><td class="memTemplParams" colspan="2">template&lt;typename ET , typename... Args&gt; </td></tr>
<tr class="memitem:ae04b4c3bc93adfb9c3cfaf866bc13d55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a>&lt; ET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ae04b4c3bc93adfb9c3cfaf866bc13d55">makeUnObHybrid</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae04b4c3bc93adfb9c3cfaf866bc13d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an <a class="el" href="structisle_1_1UnObHybridPtr.html" title="Hybrid of unique and observer pointer. ">UnObHybridPtr</a> of given pointee type.  <a href="#ae04b4c3bc93adfb9c3cfaf866bc13d55">More...</a><br /></td></tr>
<tr class="separator:ae04b4c3bc93adfb9c3cfaf866bc13d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d96123c95ced1a69a81682cd706c9"><td class="memItemLeft" align="right" valign="top"><a id="ab26d96123c95ced1a69a81682cd706c9"></a>
<a class="el" href="classisle_1_1Logger.html">Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceisle.html#ab26d96123c95ced1a69a81682cd706c9">getLogger</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab26d96123c95ced1a69a81682cd706c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new logger. <br /></td></tr>
<tr class="separator:ab26d96123c95ced1a69a81682cd706c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac5fbe80328e0f6186900cfb71ea31f47"><td class="memItemLeft" align="right" valign="top"><a id="ac5fbe80328e0f6186900cfb71ea31f47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__version__</b> = str(isleVersion)</td></tr>
<tr class="separator:ac5fbe80328e0f6186900cfb71ea31f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6bc669bc5ea7ffc1c64fe2ae77e6b"><td class="memTemplParams" colspan="2"><a id="a83b6bc669bc5ea7ffc1c64fe2ae77e6b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83b6bc669bc5ea7ffc1c64fe2ae77e6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceisle.html#a83b6bc669bc5ea7ffc1c64fe2ae77e6b">pi</a> = static_cast&lt;T&gt;(3.1415926535897932384626433832795028841971693993751058209749L)</td></tr>
<tr class="memdesc:a83b6bc669bc5ea7ffc1c64fe2ae77e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for pi up to long double precision. <br /></td></tr>
<tr class="separator:a83b6bc669bc5ea7ffc1c64fe2ae77e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base Python package of isle. </p>
<p>C++ routines.</p>
<p>Contains Python modules and imports everything from C++ extension into the isle namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af0b52b733211e398e6bc2005b717de23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b52b733211e398e6bc2005b717de23">&#9670;&nbsp;</a></span>IdMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceisle.html#af0b52b733211e398e6bc2005b717de23">isle.IdMatrix</a> = typedef blaze::IdentityMatrix&lt;ET&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An identity matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00051">51</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="abd9509585ef7b40afb903b7d621a2a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9509585ef7b40afb903b7d621a2a1f">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">isle.Matrix</a> = typedef blaze::DynamicMatrix&lt;ET&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic dense matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00037">37</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="addeb55864856a65fe3923ff9c9e9ac0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addeb55864856a65fe3923ff9c9e9ac0e">&#9670;&nbsp;</a></span>SparseMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classisle_1_1cpp__wrappers_1_1SparseMatrix.html">isle.SparseMatrix</a> = typedef blaze::CompressedMatrix&lt;ET&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00044">44</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a2b19574e84eff5030192d6e5a26c0056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b19574e84eff5030192d6e5a26c0056">&#9670;&nbsp;</a></span>SymmetricMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceisle.html#a2b19574e84eff5030192d6e5a26c0056">isle.SymmetricMatrix</a> = typedef blaze::SymmetricMatrix&lt;blaze::DynamicMatrix&lt;ET&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic symmetric dense matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00058">58</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab6b21648e9a7853156b931a081760fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b21648e9a7853156b931a081760fa9">&#9670;&nbsp;</a></span>SymmetricSparseMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceisle.html#ab6b21648e9a7853156b931a081760fa9">isle.SymmetricSparseMatrix</a> = typedef blaze::SymmetricMatrix&lt;blaze::CompressedMatrix&lt;ET&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic symmetric sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00065">65</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a07fce59b2cdee49d5429139c0682806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fce59b2cdee49d5429139c0682806f">&#9670;&nbsp;</a></span>Vec3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceisle.html#a07fce59b2cdee49d5429139c0682806f">isle.Vec3</a> = typedef blaze::StaticVector&lt;ET, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Holds spatial coordinates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00030">30</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="aeba575f1a9fca51f95d20e44b7b7be7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba575f1a9fca51f95d20e44b7b7be7b">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">isle.Vector</a> = typedef blaze::DynamicVector&lt;ET&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic dense vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa6202a7db432da01e9790291956ec778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6202a7db432da01e9790291956ec778">&#9670;&nbsp;</a></span>Species</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">isle::Species</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark particles and holes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa6202a7db432da01e9790291956ec778a5818992261344f3f6c810ea0dfc13c24"></a>PARTICLE&#160;</td><td class="fielddoc"><p>'Normal' particles. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6202a7db432da01e9790291956ec778aadec9358cd14fbdcdb29c5b2f040d712"></a>HOLE&#160;</td><td class="fielddoc"><p>Anti-particlces, or holes. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="species_8hpp_source.html#l00010">10</a> of file <a class="el" href="species_8hpp_source.html">species.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aabdd5669e340a86c44fc642cc56e1320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdd5669e340a86c44fc642cc56e1320">&#9670;&nbsp;</a></span>expmSym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a> isle::expmSym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">DMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix exponential of real, symmetrix matrices. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>mat</code> has a zero eigenvalue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Real, symmetric matrix to exponentiate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix exponential of mat. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00242">242</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a4528b02fe90b03b536ccab2b58a1cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4528b02fe90b03b536ccab2b58a1cc70">&#9670;&nbsp;</a></span>getNt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t isle::getNt </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>stVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>nx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute temporal lattice size from a spacetime vector and spatial lattice size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if vector size is not a multiple of <code>nx</code> and not in release mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stVec</td><td>An arbitrary spacetime vector. </td></tr>
    <tr><td class="paramname">nx</td><td>spatial lattice size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of time slices <code>nt = stVec.size() / nx</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00159">159</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a4d77ab2b13b2b6395281572351670877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d77ab2b13b2b6395281572351670877">&#9670;&nbsp;</a></span>getQLU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a> isle::getQLU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an LU-decomposition of Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d467ddef5485f5f264cf443a021710a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d467ddef5485f5f264cf443a021710a">&#9670;&nbsp;</a></span>getQLU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a> isle::getQLU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an LU-decomposition of Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b3ae170903a6278f447f8432787f3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3ae170903a6278f447f8432787f3bb">&#9670;&nbsp;</a></span>ilogdet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto isle::ilogdet </td>
          <td>(</td>
          <td class="paramtype">MT &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logarithm of the determinant of a dense matrix; overwrites the input. </p>
<dl class="section warning"><dt>Warning</dt><dd>This version overwrites the input matrix. See <a class="el" href="namespaceisle.html#ad4f90a990358afa056acf6efd8ec7356" title="Compute the logarithm of the determinant of a dense matrix. ">logdet()</a> for a version that does not change it. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MT</td><td>Specific matrix type, must be a blaze dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix to compute the determinant of; must be square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(y = \log \det(\mathrm{mat})\) as a complex number projected onto the first Riemann sheet of the logarithm, i.e. \(y \in (-\pi, \pi]\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00268">268</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="namespaceisle_a2b3ae170903a6278f447f8432787f3bb_cgraph.png" border="0" usemap="#namespaceisle_a2b3ae170903a6278f447f8432787f3bb_cgraph" alt=""/></div>
<map name="namespaceisle_a2b3ae170903a6278f447f8432787f3bb_cgraph" id="namespaceisle_a2b3ae170903a6278f447f8432787f3bb_cgraph">
<area shape="rect" id="node2" href="namespaceisle.html#a12355b2cfc109da544e1015b954239c2" title="Project a complex number to the first branch of the logarithm (&#45;pi, pi]. " alt="" coords="148,5,307,32"/>
</map>
</div>

</div>
</div>
<a id="ae7be0174cb3bd2485fc5d9424898bc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7be0174cb3bd2485fc5d9424898bc9e">&#9670;&nbsp;</a></span>ilogdetQ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::ilogdetQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a> &amp;&#160;</td>
          <td class="paramname"><em>lu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(Q))\) given an LU-decomposition, overwrites input. </p>
<dl class="section warning"><dt>Warning</dt><dd>This version operates in-place and overwrites the input parameter <code>lu</code>. See <code>std::complex&lt;double&gt; <a class="el" href="namespaceisle.html#ad41c26226f421b25ffd6854519717590" title="Compute  given an LU-decomposition. ">logdetQ(const HubbardFermiMatrixDia::QLU &amp;lu)</a></code> for a version that preserves <code>lu</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.Q))</code> and projected onto the first branch of the logarithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>std::complex&lt;double&gt; logdetQ(const HubbardFermiMatrixDia &amp;hfm)</code> </dd></dl>

</div>
</div>
<a id="a5b767734dee418ac317ba832189f9819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b767734dee418ac317ba832189f9819">&#9670;&nbsp;</a></span>ilogdetQ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::ilogdetQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a> &amp;&#160;</td>
          <td class="paramname"><em>lu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(Q))\) given an LU-decomposition, overwrites input. </p>
<dl class="section warning"><dt>Warning</dt><dd>This version operates in-place and overwrites the input parameter <code>lu</code>. See <code>std::complex&lt;double&gt; <a class="el" href="namespaceisle.html#ac5088489ec500cd2b3a70008c0d7fb60" title="Compute  given an LU-decomposition. ">logdetQ(const HubbardFermiMatrixExp::QLU &amp;lu)</a></code> for a version that preserves <code>lu</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.Q))</code> and projected onto the first branch of the logarithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>std::complex&lt;double&gt; logdetQ(const HubbardFermiMatrixExp &amp;hfm)</code> </dd></dl>

</div>
</div>
<a id="a59568c034bfdc0de9961737fdeaece7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59568c034bfdc0de9961737fdeaece7b">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void isle::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisle_1_1cpp__wrappers_1_1Matrix.html">Matrix</a>&lt; ET &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; int[]&gt; &amp;&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a matrix in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix to be inverted. Is replaced by the inverse. </td></tr>
    <tr><td class="paramname">ipiv</td><td>Pivot indices. Must have at least <code>mat.rows()</code> elements but can be uninitialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00223">223</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a7f5c260b13a36257088e0fa775d84ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5c260b13a36257088e0fa775d84ff2">&#9670;&nbsp;</a></span>leapfrog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a>, <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a>, std::complex&lt;double&gt; &gt; isle::leapfrog </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structisle_1_1action_1_1Action.html">action::Action</a> *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nsteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>direction</em> = <code>+1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform leapfrog integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Starting configuration. </td></tr>
    <tr><td class="paramname">pi</td><td>Starting momentum. </td></tr>
    <tr><td class="paramname">action</td><td>Action to integrate over. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the trajectory. The size of each step is <code>length/nsteps</code>. </td></tr>
    <tr><td class="paramname">nsteps</td><td>Number of integration steps. </td></tr>
    <tr><td class="paramname">direction</td><td>Direction of integration, should be <code>+1</code> or <code>-1</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (in order)<ul>
<li>final configuration phi</li>
<li>final momentum pi</li>
<li>value of action at final phi and pi </li>
</ul>
</dd></dl>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="namespaceisle_a7f5c260b13a36257088e0fa775d84ff2_icgraph.png" border="0" usemap="#namespaceisle_a7f5c260b13a36257088e0fa775d84ff2_icgraph" alt=""/></div>
<map name="namespaceisle_a7f5c260b13a36257088e0fa775d84ff2_icgraph" id="namespaceisle_a7f5c260b13a36257088e0fa775d84ff2_icgraph">
<area shape="rect" id="node2" href="classisle_1_1evolver_1_1ConstStepLeapfrog.html#a8119130ddaa30c0d6da6dbad12b15618" title="Run leapfrog integrator. " alt="" coords="157,5,421,32"/>
<area shape="rect" id="node3" href="classisle_1_1evolver_1_1LinearStepLeapfrog.html#aca2b047253c99b069aa3a4633d0615bb" title="Run leapfrog integrator. " alt="" coords="156,56,423,83"/>
</map>
</div>

</div>
</div>
<a id="ad4f90a990358afa056acf6efd8ec7356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f90a990358afa056acf6efd8ec7356">&#9670;&nbsp;</a></span>logdet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto isle::logdet </td>
          <td>(</td>
          <td class="paramtype">const MT &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logarithm of the determinant of a dense matrix. </p>
<p>Note that the matrix is copied in order to leave the original unchanged. See <a class="el" href="namespaceisle.html#a2b3ae170903a6278f447f8432787f3bb" title="Compute the logarithm of the determinant of a dense matrix; overwrites the input. ...">ilogdet()</a> for an in-place version. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MT</td><td>Specific matrix type, must be a blaze dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix to compute the determinant of; must be square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(y = \log \det(\mathrm{mat})\) as a complex number projected onto the first Riemann sheet of the logarithm, i.e. \(y \in (-\pi, \pi]\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00308">308</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><img src="namespaceisle_ad4f90a990358afa056acf6efd8ec7356_cgraph.png" border="0" usemap="#namespaceisle_ad4f90a990358afa056acf6efd8ec7356_cgraph" alt=""/></div>
<map name="namespaceisle_ad4f90a990358afa056acf6efd8ec7356_cgraph" id="namespaceisle_ad4f90a990358afa056acf6efd8ec7356_cgraph">
<area shape="rect" id="node2" href="namespaceisle.html#a12355b2cfc109da544e1015b954239c2" title="Project a complex number to the first branch of the logarithm (&#45;pi, pi]. " alt="" coords="144,5,303,32"/>
</map>
</div>

</div>
</div>
<a id="a60202a0e588287a9790abbebc1a2c236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60202a0e588287a9790abbebc1a2c236">&#9670;&nbsp;</a></span>logdetM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::logdetM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(M))\). </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Is the new form stable for mu != 0? What about complex phi? </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>HubbardFermiMatrixDia to compute the determinant of. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to use particles or holes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.M()))</code> and projected onto the first branch of the logarithm. </dd></dl>

</div>
</div>
<a id="a96bd52f1a60dd9c0c85b8aecb73bac2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bd52f1a60dd9c0c85b8aecb73bac2f">&#9670;&nbsp;</a></span>logdetM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::logdetM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(M))\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>HubbardFermiMatrixExp to compute the determinant of. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to use particles or holes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.M()))</code> and projected onto the first branch of the logarithm. </dd></dl>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><img src="namespaceisle_a96bd52f1a60dd9c0c85b8aecb73bac2f_icgraph.png" border="0" usemap="#namespaceisle_a96bd52f1a60dd9c0c85b8aecb73bac2f_icgraph" alt=""/></div>
<map name="namespaceisle_a96bd52f1a60dd9c0c85b8aecb73bac2f_icgraph" id="namespaceisle_a96bd52f1a60dd9c0c85b8aecb73bac2f_icgraph">
<area shape="rect" id="node2" href="classisle_1_1meas_1_1logdet_1_1Logdet.html#a97c06cd3fa751c6d588cc89b3125501d" title="Record logdet. " alt="" coords="156,5,335,47"/>
</map>
</div>

</div>
</div>
<a id="a9066db6c1e79360f60aebaf98d8f9a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9066db6c1e79360f60aebaf98d8f9a06">&#9670;&nbsp;</a></span>logdetQ() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::logdetQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(Q))\) by means of an LU-decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>HubbardFermiMatrixDia to compute the determinant of. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.Q()))</code> and projected onto the first branch of the logarithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>std::complex&lt;double&gt; logdet(const HubbardFermiMatrixDia::QLU &amp;lu)</code> in case you already have the LU-decomposition of Q. </dd></dl>

</div>
</div>
<a id="a4f8e05e885d8217bd60bb5f3c904846d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8e05e885d8217bd60bb5f3c904846d">&#9670;&nbsp;</a></span>logdetQ() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::logdetQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(Q))\) by means of an LU-decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>HubbardFermiMatrixExp to compute the determinant of. </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.Q()))</code> and projected onto the first branch of the logarithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>std::complex&lt;double&gt; logdet(const HubbardFermiMatrixExp::QLU &amp;lu)</code> in case you already have the LU-decomposition of Q. </dd></dl>

</div>
</div>
<a id="ad41c26226f421b25ffd6854519717590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41c26226f421b25ffd6854519717590">&#9670;&nbsp;</a></span>logdetQ() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::logdetQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a> &amp;&#160;</td>
          <td class="paramname"><em>lu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(Q))\) given an LU-decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>LU-decomposed Q. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.Q))</code> and projected onto the first branch of the logarithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><code>std::complex&lt;double&gt; logdetQ(const HubbardFermiMatrixDia &amp;hfm)</code></li>
<li><code>std::complex&lt;double&gt; <a class="el" href="namespaceisle.html#ae7be0174cb3bd2485fc5d9424898bc9e" title="Compute  given an LU-decomposition, overwrites input. ">ilogdetQ(HubbardFermiMatrixDia::QLU &amp;lu)</a></code> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac5088489ec500cd2b3a70008c0d7fb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5088489ec500cd2b3a70008c0d7fb60">&#9670;&nbsp;</a></span>logdetQ() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; isle::logdetQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a> &amp;&#160;</td>
          <td class="paramname"><em>lu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute \(\log(\det(Q))\) given an LU-decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>LU-decomposed Q. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value equivalent to <code>log(det(hfm.Q))</code> and projected onto the first branch of the logarithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><code>std::complex&lt;double&gt; logdetQ(const HubbardFermiMatrixExp &amp;hfm)</code></li>
<li><code>std::complex&lt;double&gt; <a class="el" href="namespaceisle.html#a5b767734dee418ac317ba832189f9819" title="Compute  given an LU-decomposition, overwrites input. ">ilogdetQ(HubbardFermiMatrixExp::QLU &amp;lu)</a></code> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af63e604357441025a3a439f4c8d35c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63e604357441025a3a439f4c8d35c9b">&#9670;&nbsp;</a></span>loopIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t isle::loopIdx </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loop index around boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index, can be static_cast&lt;std::size_t&gt;(-1) to represent 'one before 0'. </td></tr>
    <tr><td class="paramname">n</td><td><code>n-1</code> is the maximum value for <code>i</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Only works if i is at most one step across boundary. That is, it requires <code>-1 &lt;= i &lt;= n</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lattice_8hpp_source.html#l00165">165</a> of file <a class="el" href="lattice_8hpp_source.html">lattice.hpp</a>.</p>

</div>
</div>
<a id="ae04b4c3bc93adfb9c3cfaf866bc13d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04b4c3bc93adfb9c3cfaf866bc13d55">&#9670;&nbsp;</a></span>makeUnObHybrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ET , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a>&lt;ET&gt; isle::makeUnObHybrid </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an <a class="el" href="structisle_1_1UnObHybridPtr.html" title="Hybrid of unique and observer pointer. ">UnObHybridPtr</a> of given pointee type. </p>
<p>Allocated memory for and constructs a new object of type <code>ET</code> with given parameters and an <a class="el" href="structisle_1_1UnObHybridPtr.html" title="Hybrid of unique and observer pointer. ">UnObHybridPtr</a> which owns the allocated memory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ET</td><td>Element type of the new <a class="el" href="structisle_1_1UnObHybridPtr.html" title="Hybrid of unique and observer pointer. ">UnObHybridPtr</a>, i.e. type of pointee. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to forward to constructor of managed object of type <code>ET</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structisle_1_1UnObHybridPtr.html" title="Hybrid of unique and observer pointer. ">UnObHybridPtr</a> owning a new instance of type <code>ET</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00256">256</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ac677ca134acbf8dcc9d9b6ba1301a797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac677ca134acbf8dcc9d9b6ba1301a797">&#9670;&nbsp;</a></span>solveM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a>&gt; isle::solveM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations \(M x = b\). </p>
<p>Can be called for multiple right hand sides b in order to re-use parts of the calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>Represents matrix M which describes the system of equations. </td></tr>
    <tr><td class="paramname">phi</td><td>Gauge configuration needed to construct M. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to solve for particles or holes. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand sides b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results x, same length as rhs. </dd></dl>

</div>
</div>
<a id="a1e8229849169bc8e79c60383c6989f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8229849169bc8e79c60383c6989f68">&#9670;&nbsp;</a></span>solveM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a>&gt; isle::solveM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisle.html#aa6202a7db432da01e9790291956ec778">Species</a>&#160;</td>
          <td class="paramname"><em>species</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations \(M x = b\). </p>
<p>Can be called for multiple right hand sides b in order to re-use parts of the calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>Represents matrix M which describes the system of equations. </td></tr>
    <tr><td class="paramname">phi</td><td>Gauge configuration needed to construct M. </td></tr>
    <tr><td class="paramname">species</td><td>Select whether to solve for particles or holes. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand sides b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results x, same length as rhs. </dd></dl>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><img src="namespaceisle_a1e8229849169bc8e79c60383c6989f68_icgraph.png" border="0" usemap="#namespaceisle_a1e8229849169bc8e79c60383c6989f68_icgraph" alt=""/></div>
<map name="namespaceisle_a1e8229849169bc8e79c60383c6989f68_icgraph" id="namespaceisle_a1e8229849169bc8e79c60383c6989f68_icgraph">
<area shape="rect" id="node2" href="classisle_1_1meas_1_1chiralCondensate_1_1ChiralCondensate.html#a70dea489abb49cceadf736ee60b3061c" title="Record the chiral condensate. " alt="" coords="167,5,370,47"/>
<area shape="rect" id="node3" href="classisle_1_1meas_1_1singleParticleCorrelator_1_1SingleParticleCorrelator.html#adb732d603fe622c8a3292a093eb55a90" title="Record the single&#45;particle correlators. " alt="" coords="148,70,389,126"/>
</map>
</div>

</div>
</div>
<a id="a7dde3d243fe78b2d89ffc5a14b6e50b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dde3d243fe78b2d89ffc5a14b6e50b7">&#9670;&nbsp;</a></span>solveQ() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt;std::complex&lt;double&gt; &gt; isle::solveQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixDia.html">HubbardFermiMatrixDia</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations \(Q x = b\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>Encodes matrix \(Q\). </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side \(b\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution \(x\). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>std::complex&lt;double&gt; solveQ(const HubbardFermiMatrixDia::QLU &amp;lu)</code> in case you already have the LU-decomposition of Q. </dd></dl>

</div>
</div>
<a id="a4022f16195fbda9ab98d20b0b509231a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4022f16195fbda9ab98d20b0b509231a">&#9670;&nbsp;</a></span>solveQ() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt;std::complex&lt;double&gt; &gt; isle::solveQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisle_1_1HubbardFermiMatrixExp.html">HubbardFermiMatrixExp</a> &amp;&#160;</td>
          <td class="paramname"><em>hfm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">CDVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations \(Q x = b\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfm</td><td>Encodes matrix \(Q\). </td></tr>
    <tr><td class="paramname">phi</td><td>Auxilliary field. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side \(b\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution \(x\). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>std::complex&lt;double&gt; solveQ(const HubbardFermiMatrixExp::QLU &amp;lu)</code> in case you already have the LU-decomposition of Q. </dd></dl>

</div>
</div>
<a id="a41fa5d40004f3689355f7d48f2270833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fa5d40004f3689355f7d48f2270833">&#9670;&nbsp;</a></span>solveQ() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt;std::complex&lt;double&gt; &gt; isle::solveQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisle_1_1HubbardFermiMatrixDia_1_1QLU.html">HubbardFermiMatrixDia::QLU</a> &amp;&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations \(Q x = b\); use LU-decomposition directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>LU-Decomposition of matrix \(Q\). </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side \(b\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution \(x\). </dd></dl>

</div>
</div>
<a id="a8f0145ecf781dd4852f8bfa3fcb6efbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0145ecf781dd4852f8bfa3fcb6efbb">&#9670;&nbsp;</a></span>solveQ() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt;std::complex&lt;double&gt; &gt; isle::solveQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisle_1_1HubbardFermiMatrixExp_1_1QLU.html">HubbardFermiMatrixExp::QLU</a> &amp;&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisle_1_1cpp__wrappers_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a system of equations \(Q x = b\); use LU-decomposition directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>LU-Decomposition of matrix \(Q\). </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side \(b\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution \(x\). </dd></dl>

</div>
</div>
<a id="a65549070867f7066df6743f742447b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65549070867f7066df6743f742447b88">&#9670;&nbsp;</a></span>spacetimeCoord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t isle::spacetimeCoord </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &#160;</td>
          <td class="paramname"><em>UNUSED</em>nt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the flat spacetime coordinate for a given pair of space and time coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Spatial coordinate. </td></tr>
    <tr><td class="paramname">t</td><td>Temporal coordinate. </td></tr>
    <tr><td class="paramname">nx</td><td>Number of spatial lattice sites. </td></tr>
    <tr><td class="paramname">nt</td><td>Number of temporal lattice sites. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lattice_8hpp_source.html#l00187">187</a> of file <a class="el" href="lattice_8hpp_source.html">lattice.hpp</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><img src="namespaceisle_a65549070867f7066df6743f742447b88_cgraph.png" border="0" usemap="#namespaceisle_a65549070867f7066df6743f742447b88_cgraph" alt=""/></div>
<map name="namespaceisle_a65549070867f7066df6743f742447b88_cgraph" id="namespaceisle_a65549070867f7066df6743f742447b88_cgraph">
<area shape="rect" id="node2" href="namespaceisle.html#a6d72983170e44db6950b041426dcfa7c" title="Return true if hopping matrix is bipartite, false otherwise. " alt="" coords="209,5,324,32"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceisle.html">isle</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
