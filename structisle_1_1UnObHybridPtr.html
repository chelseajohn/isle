<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>isle: isle::UnObHybridPtr&lt; ET &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">isle
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">Lattice Monte Carlo for Carbon Nanostructures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structisle_1_1UnObHybridPtr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structisle_1_1UnObHybridPtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">isle::UnObHybridPtr&lt; ET &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hybrid of unique and observer pointer.  
 <a href="structisle_1_1UnObHybridPtr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory_8hpp_source.html">memory.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for isle::UnObHybridPtr&lt; ET &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="structisle_1_1UnObHybridPtr__coll__graph.png" border="0" usemap="#isle_1_1UnObHybridPtr_3_01ET_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="isle_1_1UnObHybridPtr_3_01ET_01_4_coll__map" id="isle_1_1UnObHybridPtr_3_01ET_01_4_coll__map">
<area shape="rect" id="node2" href="structisle_1_1PointerFlagPair.html" title="isle::PointerFlagPair\l\&lt; ET \&gt;" alt="" coords="6,5,151,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4b935ad2710d1cb2ea019f49923ebf62"><td class="memItemLeft" align="right" valign="top"><a id="a4b935ad2710d1cb2ea019f49923ebf62"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a4b935ad2710d1cb2ea019f49923ebf62">ElementType</a> = ET</td></tr>
<tr class="memdesc:a4b935ad2710d1cb2ea019f49923ebf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointee. <br /></td></tr>
<tr class="separator:a4b935ad2710d1cb2ea019f49923ebf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d63089adb9a6d48bc62ae402dd9cb0d"><td class="memItemLeft" align="right" valign="top"><a id="a7d63089adb9a6d48bc62ae402dd9cb0d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a7d63089adb9a6d48bc62ae402dd9cb0d">Pointer</a> = ET *</td></tr>
<tr class="memdesc:a7d63089adb9a6d48bc62ae402dd9cb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of raw pointer. <br /></td></tr>
<tr class="separator:a7d63089adb9a6d48bc62ae402dd9cb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac80fcac171809f78aab589a0ee9710f1"><td class="memItemLeft" align="right" valign="top"><a id="ac80fcac171809f78aab589a0ee9710f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#ac80fcac171809f78aab589a0ee9710f1">UnObHybridPtr</a> () noexcept</td></tr>
<tr class="memdesc:ac80fcac171809f78aab589a0ee9710f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to <code>nullptr</code>. <br /></td></tr>
<tr class="separator:ac80fcac171809f78aab589a0ee9710f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41956b926449cf59d8e7a8a995402b6"><td class="memItemLeft" align="right" valign="top"><a id="ad41956b926449cf59d8e7a8a995402b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#ad41956b926449cf59d8e7a8a995402b6">UnObHybridPtr</a> (const <a class="el" href="structisle_1_1UnObHybridPtr.html#a7d63089adb9a6d48bc62ae402dd9cb0d">Pointer</a> ptr, const bool owned) noexcept</td></tr>
<tr class="memdesc:ad41956b926449cf59d8e7a8a995402b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from raw pointer and set whether memory is owned. <br /></td></tr>
<tr class="separator:ad41956b926449cf59d8e7a8a995402b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0271ff6d80e1d9868e23cc0f4af2fd68"><td class="memItemLeft" align="right" valign="top"><a id="a0271ff6d80e1d9868e23cc0f4af2fd68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a0271ff6d80e1d9868e23cc0f4af2fd68">UnObHybridPtr</a> (const <a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a> &amp;)=delete</td></tr>
<tr class="memdesc:a0271ff6d80e1d9868e23cc0f4af2fd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying is not allowed. <br /></td></tr>
<tr class="separator:a0271ff6d80e1d9868e23cc0f4af2fd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9827d034230afee543fd407644a4ca69"><td class="memItemLeft" align="right" valign="top"><a id="a9827d034230afee543fd407644a4ca69"></a>
<a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a9827d034230afee543fd407644a4ca69">operator=</a> (const <a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a> &amp;)=delete</td></tr>
<tr class="memdesc:a9827d034230afee543fd407644a4ca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying is not allowed. <br /></td></tr>
<tr class="separator:a9827d034230afee543fd407644a4ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0a1531acf9deff2565eed2033577ed"><td class="memItemLeft" align="right" valign="top"><a id="a3e0a1531acf9deff2565eed2033577ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a3e0a1531acf9deff2565eed2033577ed">UnObHybridPtr</a> (<a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3e0a1531acf9deff2565eed2033577ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct and set other to <code>nullptr</code>. <br /></td></tr>
<tr class="separator:a3e0a1531acf9deff2565eed2033577ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c60014c01a3f9678383689ad5ab642"><td class="memItemLeft" align="right" valign="top"><a id="a68c60014c01a3f9678383689ad5ab642"></a>
<a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a68c60014c01a3f9678383689ad5ab642">operator=</a> (<a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a68c60014c01a3f9678383689ad5ab642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign and set other to <code>nullptr</code>. <br /></td></tr>
<tr class="separator:a68c60014c01a3f9678383689ad5ab642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c21f34ade4b5975252acf847f118ff"><td class="memItemLeft" align="right" valign="top"><a id="a55c21f34ade4b5975252acf847f118ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a55c21f34ade4b5975252acf847f118ff">swap</a> (<a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a55c21f34ade4b5975252acf847f118ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with other pointer. <br /></td></tr>
<tr class="separator:a55c21f34ade4b5975252acf847f118ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454e30838ec46629fb371365ce6e0bef"><td class="memItemLeft" align="right" valign="top"><a id="a454e30838ec46629fb371365ce6e0bef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a454e30838ec46629fb371365ce6e0bef">reset</a> (const <a class="el" href="structisle_1_1UnObHybridPtr.html#a7d63089adb9a6d48bc62ae402dd9cb0d">Pointer</a> p, const bool owned) noexcept</td></tr>
<tr class="memdesc:a454e30838ec46629fb371365ce6e0bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set from a new pointer and free old memory if owned. <br /></td></tr>
<tr class="separator:a454e30838ec46629fb371365ce6e0bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6568d45b169560b9ee7da2760cfe930"><td class="memItemLeft" align="right" valign="top"><a id="ae6568d45b169560b9ee7da2760cfe930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#ae6568d45b169560b9ee7da2760cfe930">reset</a> (const std::nullptr_t p=nullptr) noexcept</td></tr>
<tr class="memdesc:ae6568d45b169560b9ee7da2760cfe930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to <code>nullptr</code> and free old memory if owned. <br /></td></tr>
<tr class="separator:ae6568d45b169560b9ee7da2760cfe930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c51b0c8cd798a3bc618eac3d49a6088"><td class="memItemLeft" align="right" valign="top"><a id="a6c51b0c8cd798a3bc618eac3d49a6088"></a>
<a class="el" href="structisle_1_1UnObHybridPtr.html#a7d63089adb9a6d48bc62ae402dd9cb0d">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a6c51b0c8cd798a3bc618eac3d49a6088">get</a> () const noexcept</td></tr>
<tr class="memdesc:a6c51b0c8cd798a3bc618eac3d49a6088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get raw pointer to managed object, <code>nullptr</code> if nothing owned. <br /></td></tr>
<tr class="separator:a6c51b0c8cd798a3bc618eac3d49a6088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0960c57215af240009fa6c2e6deba868"><td class="memItemLeft" align="right" valign="top"><a id="a0960c57215af240009fa6c2e6deba868"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a0960c57215af240009fa6c2e6deba868">owns</a> () const noexcept</td></tr>
<tr class="memdesc:a0960c57215af240009fa6c2e6deba868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrun whether current memory is owned; if nothing owned, returns <code>false</code>. <br /></td></tr>
<tr class="separator:a0960c57215af240009fa6c2e6deba868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19aff7f7594370eb0994f364094625b2"><td class="memItemLeft" align="right" valign="top"><a id="a19aff7f7594370eb0994f364094625b2"></a>
<a class="el" href="structisle_1_1UnObHybridPtr.html#a7d63089adb9a6d48bc62ae402dd9cb0d">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a19aff7f7594370eb0994f364094625b2">release</a> () noexcept</td></tr>
<tr class="memdesc:a19aff7f7594370eb0994f364094625b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return raw pointer to managed object and set UnObHybridPtr to <code>nullptr</code>. <br /></td></tr>
<tr class="separator:a19aff7f7594370eb0994f364094625b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ab8c536928dd1e3ef62d72c6ce20b4"><td class="memItemLeft" align="right" valign="top"><a id="ae8ab8c536928dd1e3ef62d72c6ce20b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#ae8ab8c536928dd1e3ef62d72c6ce20b4">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ae8ab8c536928dd1e3ef62d72c6ce20b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if an object is managed, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:ae8ab8c536928dd1e3ef62d72c6ce20b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fc381635e7bfaed2c437ad267711e3"><td class="memItemLeft" align="right" valign="top"><a id="a00fc381635e7bfaed2c437ad267711e3"></a>
std::add_lvalue_reference_t&lt; <a class="el" href="structisle_1_1UnObHybridPtr.html#a4b935ad2710d1cb2ea019f49923ebf62">ElementType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a00fc381635e7bfaed2c437ad267711e3">operator*</a> () const</td></tr>
<tr class="memdesc:a00fc381635e7bfaed2c437ad267711e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference pointer, i.e. return managed object. <br /></td></tr>
<tr class="separator:a00fc381635e7bfaed2c437ad267711e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24679c6869195d295e56a9ffbf8b80da"><td class="memItemLeft" align="right" valign="top"><a id="a24679c6869195d295e56a9ffbf8b80da"></a>
<a class="el" href="structisle_1_1UnObHybridPtr.html#a7d63089adb9a6d48bc62ae402dd9cb0d">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a24679c6869195d295e56a9ffbf8b80da">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a24679c6869195d295e56a9ffbf8b80da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to managed object. <br /></td></tr>
<tr class="separator:a24679c6869195d295e56a9ffbf8b80da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad2c79e8b85024b726e5025205c148fcc"><td class="memItemLeft" align="right" valign="top"><a id="ad2c79e8b85024b726e5025205c148fcc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#ad2c79e8b85024b726e5025205c148fcc">_PtrFlag</a> = <a class="el" href="structisle_1_1PointerFlagPair.html">PointerFlagPair</a>&lt; ET &gt;</td></tr>
<tr class="memdesc:ad2c79e8b85024b726e5025205c148fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to hold pointer and flag. <br /></td></tr>
<tr class="separator:ad2c79e8b85024b726e5025205c148fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae6d1f704d580ebc43671a3b601b7c170"><td class="memItemLeft" align="right" valign="top"><a id="ae6d1f704d580ebc43671a3b601b7c170"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#ae6d1f704d580ebc43671a3b601b7c170">_reset</a> (const <a class="el" href="structisle_1_1UnObHybridPtr.html#ad2c79e8b85024b726e5025205c148fcc">_PtrFlag</a> pfp)</td></tr>
<tr class="memdesc:ae6d1f704d580ebc43671a3b601b7c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset using a _PtrFlag object. <br /></td></tr>
<tr class="separator:ae6d1f704d580ebc43671a3b601b7c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7af121a897ef8a26bbeecadc64dfe9fb"><td class="memItemLeft" align="right" valign="top"><a id="a7af121a897ef8a26bbeecadc64dfe9fb"></a>
<a class="el" href="structisle_1_1UnObHybridPtr.html#ad2c79e8b85024b726e5025205c148fcc">_PtrFlag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisle_1_1UnObHybridPtr.html#a7af121a897ef8a26bbeecadc64dfe9fb">_pfp</a></td></tr>
<tr class="memdesc:a7af121a897ef8a26bbeecadc64dfe9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined pointer to managed object and ownership flag. <br /></td></tr>
<tr class="separator:a7af121a897ef8a26bbeecadc64dfe9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ET&gt;<br />
struct isle::UnObHybridPtr&lt; ET &gt;</h3>

<p>Hybrid of unique and observer pointer. </p>
<p>Either owns some memory or observes it. This means that the object referenced by this pointer is automatically deleted in the destructor of UnObHybridPtr if it is owned. If it is not owned no memory will be deallocated.</p>
<p>The user selects which mode the hybrid pointer is in and is responsible for choosing the right one. The object referenced by the hybrid pointer must be managed by the user if the hybrid pointer does not own it.</p>
<p>Using an UnObHybridPtr is only slightly safer than using a raw pointer. So special care has to be taken when choosing it and standard smart pointers should be preferred when possible.</p>
<p>UnObHybridPtr can not be copied in order to allow for unique references.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Et</td><td>Type of the pointee. Needs to satisfy the alignment restrictions of the pointee of a <a class="el" href="structisle_1_1PointerFlagPair.html" title="Hold a pointer and a flag in one piece of memory. ">PointerFlagPair</a>, i.e. must be aligned to a boundary larger than 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceisle.html#ae04b4c3bc93adfb9c3cfaf866bc13d55" title="Make an UnObHybridPtr of given pointee type. ">makeUnObHybrid</a></code> for a helper function to construct owning hybrid pointers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00145">145</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/travis/build/jl-wynen/isle/src/isle/cpp/<a class="el" href="memory_8hpp_source.html">memory.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceisle.html">isle</a></li><li class="navelem"><a class="el" href="structisle_1_1UnObHybridPtr.html">UnObHybridPtr</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
